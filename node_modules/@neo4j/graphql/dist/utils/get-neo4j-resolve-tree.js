"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const graphql_parse_resolve_info_1 = require("graphql-parse-resolve-info");
const neo4j_driver_1 = __importDefault(require("neo4j-driver"));
function getNeo4jArgumentValue({ argument, type }) {
    if (argument === null) {
        return argument;
    }
    if (type.toString().endsWith("!")) {
        return getNeo4jArgumentValue({ argument, type: type.ofType });
    }
    if (type.toString().startsWith("[") && type.toString().endsWith("]")) {
        return argument.map((a) => getNeo4jArgumentValue({ argument: a, type: type.ofType }));
    }
    if (type instanceof graphql_1.GraphQLInputObjectType) {
        return Object.entries(argument).reduce((res, [key, value]) => {
            const field = Object.values(type.getFields()).find((f) => f.name === key);
            if (!field) {
                throw new Error(`Error whilst generating Neo4j resolve tree: could not find field ${key} in type ${type.name}`);
            }
            return Object.assign(Object.assign({}, res), { [key]: getNeo4jArgumentValue({ argument: value, type: field.type }) });
        }, {});
    }
    if (type instanceof graphql_1.GraphQLScalarType) {
        return type.name === "Int" ? neo4j_driver_1.default.int(argument) : argument;
    }
    return argument;
}
function getNeo4jResolveTree(resolveInfo, options) {
    const resolveTree = (options === null || options === void 0 ? void 0 : options.resolveTree) || graphql_parse_resolve_info_1.parseResolveInfo(resolveInfo);
    let field;
    if (options === null || options === void 0 ? void 0 : options.field) {
        field = options.field;
    }
    else {
        const queryType = resolveInfo.schema.getQueryType();
        const mutationType = resolveInfo.schema.getMutationType();
        field = Object.values(Object.assign(Object.assign({}, queryType === null || queryType === void 0 ? void 0 : queryType.getFields()), mutationType === null || mutationType === void 0 ? void 0 : mutationType.getFields())).find((f) => f.name === resolveTree.name);
    }
    const args = Object.entries(resolveTree.args).reduce((res, [name, value]) => {
        const argument = field.args.find((arg) => arg.name === name);
        if (!argument) {
            throw new Error(`Error whilst generating Neo4j resolve tree: could not find argument ${name} on field ${field.name}`);
        }
        return Object.assign(Object.assign({}, res), { [name]: getNeo4jArgumentValue({ argument: value, type: argument.type }) });
    }, {});
    const fieldsByTypeName = Object.entries(resolveTree.fieldsByTypeName).reduce((res, [typeName, fields]) => {
        var _a, _b;
        let type;
        // eslint-disable-next-line no-underscore-dangle,@typescript-eslint/naming-convention
        const _type = resolveInfo.schema.getType(typeName);
        if (!_type) {
            throw new Error(`Error whilst generating Neo4j resolve tree: could not find type with name ${typeName} in schema`);
        }
        if (((_a = _type.astNode) === null || _a === void 0 ? void 0 : _a.kind) === "ObjectTypeDefinition") {
            type = _type;
        }
        else if (((_b = _type.astNode) === null || _b === void 0 ? void 0 : _b.kind) === "InterfaceTypeDefinition") {
            type = _type;
        }
        else {
            return Object.assign(Object.assign({}, res), { [typeName]: fields });
        }
        const resolveTrees = Object.entries(fields).reduce((trees, [fieldName, f]) => {
            return Object.assign(Object.assign({}, trees), { [fieldName]: getNeo4jResolveTree(resolveInfo, {
                    resolveTree: f,
                    field: Object.values(type.getFields()).find((typeField) => typeField.name === f.name),
                }) });
        }, {});
        return Object.assign(Object.assign({}, res), { [typeName]: resolveTrees });
    }, {});
    const { alias, name } = resolveTree;
    return { alias, args, fieldsByTypeName, name };
}
exports.default = getNeo4jResolveTree;
//# sourceMappingURL=get-neo4j-resolve-tree.js.map